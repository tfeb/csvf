#!/usr/bin/env python
#
# * Cut fields from CSV files
#
#    csvf [-s sep] [-m mri] [-f fmt]
#         [-c f v] ...
#         [-e p r] ...
#         [-r s r] ...
#          field ... < csvfile
#
# prints the fields of a csv file.
#
# Field numbers start from 1: If you give no field specifications all
# the fields are printed.  Field numbers greater than the length of
# the row are replaced by the missing record indicator which is by
# default "-".  Fields are separated defaultly by " ".  The format
# string which controls how fields are printed is defaultly "\"{0}\"",
# which means they have quotes around them.  There are options to
# control these.
#
# as an example
#
#    csvf -s : -f '{0}' < ...
#
# will print all the fields of the file, with colons separating them &
# without quotes.
#
#
# ** Options
#
# -s sep sets the separator string, defaultly a space.
#
# -m mri sets the missing record indicator, defaultly "-".
#
# -f fmt sets the output format string, defaultly "\"{0}\"": This is a
# Python format string.
#
# -w will cause it to write CSV.  In this case only the missing record
# indicator matters: the rest is taken care of by the CSV writer.
#
# -d dialect sets the CSV dialect for both input & output.  The
# default is usually fine
#
# -p module names a 'processor module' which is imported.  It should
# have a function called 'process' which takes a row and returns
# another row.  This option can be repeated, and the processors are
# applied in order.  A processor can also return None which abort
# processing of that row: no further processors will be called and
# nothing will be printed.
#
# -c f v will force field f to value v.
#
# -e f p r will, for field f, use p and r as regexp pattern &
# -substitution.  -e is for 'edit'
#
# -r f s r will, if field f is the string s, replace it by r.  -r is
# -for 'replace' and this is simpler than using regexps!
#
# the above four operations happen in that order: rows are processed,
# then fields are forced to a constant value, then they are edited as
# regexps, finally fixed string replacements happen.  I don't know if
# this order is best, but that's what it is.
#
# Field editing operations don't work on missing fields, so you can't
# extend rows by forcing fields to a constant.
#
#
# ** Notes
#
# This is not particularly well-tested code.  Error handling is
# rudimentary.
#

from sys import stdin, stdout, argv, exit
from csv import reader as csv_reader, writer as csv_writer
from argparse import ArgumentParser
from re import compile as re_compile
from importlib import import_module

# Default values
default_sep = " "               # separator
default_mri = "-"               # missing record indicator
default_fmt = "\"{0}\""         # record formatter function
default_csv_dialect = 'excel'   # default dialect

def main(arguments):
    # the program
    parser = ArgumentParser(
        description="cut fields from a CSV file, with possible edits")
    parser.add_argument("-s", "--separator",
                        dest='sep', default=default_sep,
                        help="The output separator, default '{}'"
                        .format(default_sep))
    parser.add_argument("-m", "--missing-record-indicator",
                        dest='mri', default=default_mri,
                        help="Printed for missing records, default '{}'"
                        .format(default_mri))
    parser.add_argument("-f", "--format-string",
                        dest='fmt', default=default_fmt,
                        help="Format string for records, default '{}'"
                        .format(default_fmt))
    parser.add_argument("-c", "--constant",
                        nargs=2, dest='constants', action='append',
                        default=[],
                        metavar=("FIELD", "VALUE"),
                        help="Constant field specifications")
    parser.add_argument("-e", "--edit",
                        nargs=3, dest='edits', action='append',
                        default=[],
                        metavar=("FIELD", "PATTERN", "REPLACEMENT"),
                        help="Edit specifications (regexp replacements)")
    parser.add_argument("-r", "--replacement",
                        nargs=3, dest='replacements', action='append',
                        default=[],
                        metavar=("FIELD", "STRING", "REPLACEMENT"),
                        help="Field replacement specifications")
    parser.add_argument("-w", "--write-csv",
                        dest='csvp', action='store_true',
                        help="Write CSV output")
    parser.add_argument("-d" "--dialect",
                        dest='csv_dialect', default=default_csv_dialect,
                        help="The CSV dialect, defaultly '{}'"
                        .format(default_csv_dialect))
    parser.add_argument("-p", "--processor-module",
                        dest='processors', action='append',
                        default=[],
                        metavar="MODULE",
                        help="Name of a module to process rows")
    parser.add_argument('fields',
                        nargs='*', type=int, default=[],
                        metavar="FIELD",
                        help="The fields to print")
    parsed = parser.parse_args(arguments)
    sep = parsed.sep
    mri = parsed.mri
    fmt = parsed.fmt
    csvp = parsed.csvp
    csv_dialect=parsed.csv_dialect
    if len(parsed.fields) != 0:
        fields = tuple(field -1 for field in parsed.fields)
        for f in fields:
            if f < 0:
                raise Exception("field numbers should be positive")
    else:
        fields = None
    constants = tuple((int(c[0]) -1, c[1])
                      for c in parsed.constants)
    for c in constants:
        if c[0] < 0:
            raise Exception("constant field numbers should be positive")
    edits = tuple((int(e[0]) - 1, re_compile(e[1]), e[2])
                  for e in parsed.edits)
    for e in edits:
        if e[0] < 0:
            raise Exception("edit field numbers should be positive")
    replacements = tuple((int(r[0]) - 1, r[1], r[2])
                         for r in parsed.replacements)
    for r in replacements:
        if r[0] < 0:
            raise Exception("replacement field numbers should be positive")
    processors = tuple(import_module(m) for m in parsed.processors)

    if csvp:
        def writer(row):
            csv_writer(stdout, dialect=csv_dialect).writerow(tuple(row))
    else:
        def writer(row):
            print(sep.join(fmt.format(e) for e in row))
    for row in (rewrite_row(r, processors, constants, edits, replacements)
                for r in csv_reader(stdin, dialect=csv_dialect)):
        if row is None:
            continue
        l = len(row)
        writer(((row[f] if f < l else mri) for f in fields)
                          if fields is not None
                   else row)

def rewrite_row(row, processors, constants, edits, replacements):
    # Destructively rewrite the fields in a row according to
    # processors, replacements, edits & constants Note the order this
    # happens: rows are processed by all of the processors, then
    # fields are first driven to constants, then edits are done, then
    # fixed replacements are done.  I am not sure if this is the best
    # order, but it seems reasonable.  This can mutate row.
    l = len(row)
    for p in processors:
        row = p.process(row)
        if p is None:
            return None
    for (f, c) in constants:
        if f < len(row):
            row[f] = c
    for (f, p, r) in edits:
        if f < len(row):
            row[f] = p.sub(r, row[f])
    for (f, s, r) in replacements:
        if f < len(row):
            if row[f] == s:
                row[f] = r
    return row


if __name__ == '__main__':
    try:
        main(argv[1::])
    except Exception as e:
        exit(e)
else:
    raise Exception("not a module")
