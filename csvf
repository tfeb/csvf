#!/usr/bin/env python
#
# * Cut fields from CSV files
#
#    csvf [-s sep] [-m mri] [-f fmt]
#         [-c f v] ...
#         [-e p r] ...
#         [-r s r] ...
#          field ... < csvfile
#
# prints the fields of a csv file.
#
# Field numbers start from 1: If you give no field specifications all
# the fields are printed.  Field numbers greater than the length of
# the row are replaced by the missing record indicator which is by
# default "-".  Fields are separated defaultly by " ".  The format
# string which controls how fields are printed is defaultly "\"{0}\"",
# which means they have quotes around them.  There are options to
# control these.
#
# as an example
#
#    csvf -s : -f '{0}' < ...
#
# will print all the fields of the file, with colons separating them &
# without quotes.
#
#
# ** Options
#
# -s sep sets the separator string, defaultly a space.
#
# -m mri sets the missing record indicator, defaultly "-".
#
# -f fmt sets the output format string, defaultly "\"{0}\"": This is a
# Python format string.
#
# -w will cause it to write CSV.  In this case only the missing record
# indicator matters: the rest is taken care of by the CSV writer.
#
# -d dialect sets the CSV dialect for both input & output.  The
# default is usually fine
#
# -c f v will force field f to value v.
#
# -e f p r will, for field f, use p and r as regexp pattern &
# -substitution.  -e is for 'edit'
#
# -r f s r will, if field f is the string s, replace it by r.  -r is
# -for 'replace' and this is simpler than using regexps!
#
# the above operations happen in that order: fields are forced to
# a constant value, then they are edited as regexps, finally fixed
# string replacements happen.  I don't know if this order is best, but
# that's what it is.
#
# Field editing operations don't work on missing fields, so you can't
# extend rows by forcing fields to a constant.
#
#
# Processor modules
#
# -P module names a 'processor module' which is imported.  It should
# have a function called 'process' which takes a row and returns
# another row.  This option can be repeated, and the processors are
# applied in order.  A processor can also return None which abort
# processing of that row: no further processors will be called and
# nothing will be printed.  Processing happens before any other
# operation.
#
# If a processor module contains a function called 'enter' this will
# be called before any processing, with arguments provided with '-A'.
# If it contains a function called 'exit' this will be called at the
# end, in the same way that a context manager's '__exit__' function is
# and with the same semantics.

#
#
# ** Notes
#
# This is not particularly well-tested code.  Error handling is
# rudimentary.
#

from __future__ import print_function
from sys import stdin, stdout, argv, exit
from csv import reader as csv_reader, writer as csv_writer
from argparse import ArgumentParser
from re import compile as re_compile
from importlib import import_module

# Default values
default_sep = " "               # separator
default_mri = "-"               # missing record indicator
default_fmt = "\"{0}\""         # record formatter function
default_csv_dialect = 'excel'   # default dialect

debugging = False

class PMManager(object):
    # Wraps a processing module to provide a context manager
    def __init__(self, processor_module, arguments):
        self.processor_module = processor_module
        self.arguments = arguments
    def __enter__(self):
        if hasattr(self.processor_module, 'enter'):
            self.processor_module.enter(*self.arguments)
    def __exit__(self, extype, exval, extb):
        if hasattr(self.processor_module, 'exit'):
            return self.processor_module.exit(extype, exval, extb)
        else:
            return None
    def process(self, row):
        return self.processor_module.process(row)

def main(arguments):
    # the program
    global debugging
    parser = ArgumentParser(
        description="cut fields from a CSV file, with possible edits")
    parser.add_argument("-s", "--separator",
                        dest='sep', default=default_sep,
                        help="The output separator, default '{}'"
                        .format(default_sep))
    parser.add_argument("-m", "--missing-record-indicator",
                        dest='mri', default=default_mri,
                        help="Printed for missing records, default '{}'"
                        .format(default_mri))
    parser.add_argument("-f", "--format-string",
                        dest='fmt', default=default_fmt,
                        help="Format string for records, default '{}'"
                        .format(default_fmt))
    parser.add_argument("-c", "--constant",
                        nargs=2, dest='constants', action='append',
                        default=[],
                        metavar=("FIELD", "VALUE"),
                        help="Constant field specifications")
    parser.add_argument("-e", "--edit",
                        nargs=3, dest='edits', action='append',
                        default=[],
                        metavar=("FIELD", "PATTERN", "REPLACEMENT"),
                        help="Edit specifications (regexp replacements)")
    parser.add_argument("-r", "--replacement",
                        nargs=3, dest='replacements', action='append',
                        default=[],
                        metavar=("FIELD", "STRING", "REPLACEMENT"),
                        help="Field replacement specifications")
    parser.add_argument("-w", "--write-csv",
                        dest='csvp', action='store_true',
                        help="Write CSV output")
    parser.add_argument("-d" "--dialect",
                        dest='csv_dialect', default=default_csv_dialect,
                        metavar="DIALECT",
                        help="The CSV dialect, defaultly '{}'"
                        .format(default_csv_dialect))
    parser.add_argument("-P", "--processor-module",
                        dest='processors', action='append',
                        default=[],
                        metavar="MODULE",
                        help="Name of a module to process rows")
    parser.add_argument("-A", "--processor-argument",
                        dest='processor_arguments', action='append',
                        default=[],
                        metavar="ARGUMENT",
                        help="Arguments passed to processor modules")
    parser.add_argument("-D", "--debugging",
                        dest='debugging', action='store_true',
                        help="debug: don't catch errors, at least")
    parser.add_argument('fields',
                        nargs='*', type=int, default=[],
                        metavar="FIELD",
                        help="The fields to print")
    parsed = parser.parse_args(arguments)
    debugging = parsed.debugging
    sep = parsed.sep
    mri = parsed.mri
    fmt = parsed.fmt
    csvp = parsed.csvp
    csv_dialect = parsed.csv_dialect
    if len(parsed.fields) != 0:
        fields = tuple(field -1 for field in parsed.fields)
        for f in fields:
            if f < 0:
                raise Exception("field numbers should be positive")
    else:
        fields = None
    constants = tuple((int(c[0]) -1, c[1])
                      for c in parsed.constants)
    for c in constants:
        if c[0] < 0:
            raise Exception("constant field numbers should be positive")
    edits = tuple((int(e[0]) - 1, re_compile(e[1]), e[2])
                  for e in parsed.edits)
    for e in edits:
        if e[0] < 0:
            raise Exception("edit field numbers should be positive")
    replacements = tuple((int(r[0]) - 1, r[1], r[2])
                         for r in parsed.replacements)
    for r in replacements:
        if r[0] < 0:
            raise Exception("replacement field numbers should be positive")
    # writer is a the function called to write a row.
    writer = ((lambda row:
               csv_writer(stdout, dialect=csv_dialect).writerow(tuple(row)))
              if csvp
              else (lambda row:
                    print(sep.join(fmt.format(e) for e in row))))
    processors = tuple(PMManager(import_module(m), parsed.processor_arguments)
                       for m in parsed.processors)

    def run_with_managers(cm, nm):
        # wrap suitable context managers around execution.  This
        # should be a toplevel function, but it's too fiddly to do
        # now.
        if cm == nm:
            for row in (rewrite_row(r, processors, constants,
                                    edits, replacements)
                        for r in csv_reader(stdin, dialect=csv_dialect)):
                if row is None:
                    continue
                l = len(row)
                writer(((row[f] if f < l else mri) for f in fields)
                       if fields is not None
                       else row)
        else:
            with processors[cm]:
                run_with_managers(cm + 1, nm)

    run_with_managers(0, len(processors))
        
def rewrite_row(row, processors, constants, edits, replacements):
    # Destructively rewrite the fields in a row according to
    # processors, replacements, edits & constants Note the order this
    # happens: rows are processed by all of the processors, then
    # fields are first driven to constants, then edits are done, then
    # fixed replacements are done.  I am not sure if this is the best
    # order, but it seems reasonable.  This can mutate row.
    l = len(row)
    for p in processors:
        row = p.process(row)
        if row is None:
            return None
    for (f, c) in constants:
        if f < len(row):
            row[f] = c
    for (f, p, r) in edits:
        if f < len(row):
            row[f] = p.sub(r, row[f])
    for (f, s, r) in replacements:
        if f < len(row):
            if row[f] == s:
                row[f] = r
    return row


if __name__ == '__main__':
    try:
        main(argv[1::])
    except Exception as e:
        if not debugging:
            exit(e)
        else:
            raise
else:
    raise Exception("not a module")
